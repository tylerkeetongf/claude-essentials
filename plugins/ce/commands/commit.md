---
description: Create a well-formatted git commit for current changes
argument-hint: "[context]"
allowed-tools: Bash, Task
---

Create a git commit using the appropriate path based on your current knowledge.

## Decision: Direct vs Delegate

**Commit directly** if you have clear context about the changes:
- You just implemented, fixed, or modified something in this conversation
- You know exactly what files changed and why
- The intent of the change is unambiguous

**Delegate to haiku agent** if ambiguous:
- User invoked `/ce:commit` without prior context in this conversation
- You're unsure what changes exist or their purpose
- The user is asking about changes you didn't make

## Path A: Direct Commit (You Have Context)

1. **Quick verification:**
   ```bash
   git diff --cached --name-only  # or git diff --name-only for unstaged
   ```
   Confirm the files match what you expect from your work.

2. **Draft the message** following Conventional Commits (schema below).

3. **Execute:**
   ```bash
   git commit -m "your_header" -m "your_body"
   ```

4. **Handle failure:** If pre-commit hooks fail, report the error and stop. Don't auto-fix.

## Path B: Delegate to Haiku Agent (Ambiguous)

Invoke `ce:haiku` agent via Task tool with this prompt:

```
Create a git commit.

User arguments: $ARGUMENTS
Default context: staged (use "unstaged" only if user specifies)

**Step 1: Context Gathering**
- Execute `git log -n 10 --oneline` to learn the project's existing casing and scoping conventions
- Execute `git diff --cached --name-only` (for staged) or `git diff --name-only` (for unstaged) to see the file list
- Execute `git diff --cached` (for staged) or `git diff` (for unstaged) to read the code changes

**Step 2: Analysis & Drafting**
- Analyze the *intent* of the change (Why was this done?), not just the syntax (What changed?)
- Infer the **scope** from the directory name or module (e.g., `src/auth/login.ts` -> `auth`). Avoid file extensions in scopes
- Draft the message following **Conventional Commits** (rules below)

**Step 3: Execution**
- Print the drafted message clearly so the user sees what is being committed
- Execute: `git commit -m "your_header" -m "your_body"`
- Pass the header and body as separate `-m` flags for proper newline formatting

**Failure Handling (Pre-commit Hooks)**

If `git commit` fails (exit code != 0):
1. STOP. Do not attempt to fix linting or test errors
2. REPORT with:
   - Status: FAILED
   - Error Output: The stderr from the git command
   - Drafted Message: The message you tried to use
   - Recommendation: "Please fix the errors listed above"
```

## Commit Message Style

Follow **The Contributor** persona from `Skill(ce:writer)` for commit message conventions.

**Quick reference:**
- Format: `<type>(<scope>): <subject>` + body
- Types: `feat`, `fix`, `docs`, `refactor`, `perf`, `test`, `build`, `ci`, `chore`
- Header: 50 chars max, imperative mood, lowercase, no period
- Body: 72 char wrap, focus on WHY not WHAT
- Breaking: Use `feat!:` or `fix!:` prefix

**Important:**
- Do not add Claude attribution footers (no "Generated by..." / "Co-authored-by...")
- If the diff is massive, focus on the *primary* architectural change rather than listing every file
